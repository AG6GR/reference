
How to integrate with IFTTT
===========================

### NOTE: Running this code relies on you having access to IFTTT's developer portal. Currently, they are pretty picky about who they let in. Please don't contact Electric Imp for access. Reach out to IFTTT [here](https://ifttt.com/platform).

You will need two or more devices, one to be a permanent proxy for the other devices. You can, of course, port the agent code to an external server into the language of your choice but for now that remains an excersize for the reader.

Note: The #includes you see in the .nut files are my personal notation format for saying "go get another file and copy the contents into here." Specifically ...

- [rocky.agent.nut](https://github.com/electricimp/reference/blob/master/utility/communications/rocky.agent.nut) - The http framework class
- [ifttt.agent.nut](https://github.com/electricimp/reference/blob/master/webservices/ifttt/ifttt.agent.nut) - The IFTTT integration class


### Step 1 - Setup the proxy device

Find a new device that will be used exclusively as a proxy server. The hardware will not be used so an April is the simplest and cheapest option. You will need to place ifttt_proxy.agent.nut into the model and leave the device code empty.

Replace the PROXY_API_KEY constant with a hard-to-guess key of your choosing. I like to use http://randomkeygen.com/. Record the key you have used and the agent URL of the device. Both will be needed in step 2.


### Step 2 - Set up the target device(s)

Next, choose one of the examples and put ifttt_exmaple.agent.nut and ifttt_example.device.nut in the model for your target device. The first challenge you will have integrating this into a real device model is likely to be a conflict with your existing http.onrequest handler. But we will start on a fresh model to get things going. The example hardware I have described here has a button on pin1 and an LED on pin9.

In the agent code, replace PROXY_API_KEY and PROXY_URL with the values you recorded in step 1. You will need to give your agent a CLIENT_ID (a readable but unique slug) and a CLIENT_SECRET (another shared secret key). The CHANNEL_KEY will be provided in a later step.

You are supposed to have "users" with names, which I have set to "My Big Red Button" for all users. I would recommend you ask the user their name and set (and probably persist) this value in the ifttt.name property. It's not critical.


### Step 3 - Create a channel in IFTTT

Login to IFTTT and [create a channel](https://ifttt.com/developers/channels). Set the following details:

0. API URL Prefix = Your proxy's agent URL from step 1.
0. Enable authentication and select "My Channel has users with non-expiring OAuth2 access tokens". Enter the CLIENT_ID and CLIENT_SECRET values you generated in step 2. Copy the example "Authorization URL" and "Token URL" into the URL fields.
0. Add a trigger called "Button pressed" with the trigger end point "button_pressed". The default ingredient, "CreatedAt" will do for now. 
0. Every trigger that supports multiple devices in the same channel must, at least, contain one trigger named "device". It should be configured as a dropdown list to be retrieved from your service. 
0. We won't create any actions but they are not very different from triggers.

Note, you will need to copy the "IFTTT Channel Key" from the authentication screen into the CHANNEL_KEY const in the agent code of your target device.


###Step 4 - Build your hardware

This example is intentionally simple and all you need is to put a button on pin1 of the imp device. I recommend you do that or something similar just to complete the working scenario.


### Step 5 - Test

The "Endpoint" tests should all pass without any changes. The test scripts are automatically generated by the code based on the triggers and actions you configure.

The authentication test requires the input of a one-time code. Normally your smartphone application would request a one-time code by hitting (https://agents.electricimp.com/YOUR_AGENTID/oauth2/register). You will need to pass in three query parameters: 

0. userid - this must uniquely identify the user as it will group the users devices together. If nothing else is available, use the planId.
0. username - this will be displayed to the user once they have activated their device. If nothing else is avilable use an email address.
0. name - this is the device's name and will be displayed to the user whenever they need to select a device from a dropdown list. The user should provide this name as a friendly and memorable name for the device.

It will return a JSON object containing the code which you should display to the user. This code is valid for 60 seconds and should be entered into the Activation prompt on IFTTT. During testing you can request this data with your browser to the same URL.

### Step 6 - Customise your code and your channel

Once you have a simple application up and running you will want to build out your complete device integration; build out all the actions and triggers; and customise the look-and-feel of the activation HTML in the AUTH_HTML const.

The IFTTT integration only has a few public function you need to worry about.

- ```test_setup(callback)``` - IFTTT calls this event handler when it wants you to setup your trigger tests. You must configure at least four events for each trigger.
- ```test_teardown(callback)``` - IFTTT calls this event handler when all the tests are finished so you can remove unused test data. (They have not actually implemented this yet).

- ```add_action_field(action, field, label, value)``` - Each action field value that appears in your IFTTT configuration must be replicated with this function.
- ```action(action_name, callback)``` - When an action is detected the callback you configure here will be executed.
- ```action_ok(context)``` - When your action handler is complete, you need to execute this function to notify IFTTT of the successful handling of the event.

- ```add_trigger_field(trigger, field, label, value)``` - Each trigger efield value that appears in your IFTTT configuration must be replicated with this function. There are five different versions of this function call:

    0. ```add_trigger_field(trigger)``` - A trigger with no fields
    0. ```add_trigger_field(trigger, field)``` - A trigger with a field but no options and no validation requirement.
    0. ```add_trigger_field(trigger, callback)``` - A trigger with a callback function to filter the trigger fields before sending to IFTTT.
    0. ```add_trigger_field(trigger, field, callback)``` - A trigger field with a callback function to validate the entered value.
    0. ```add_trigger_field(trigger, field, label, value)``` - A trigger field with a dynamic dropdown list of values.

- ```trigger(trigger, ingredients, realtime)``` - When an event in your device needs to notify IFTTT of a trigger, use this function. Ingredients should be a table where the contents match the trigger ingredients and fields exactly. The "CreatedAt" ingredient and "device" field will be added automatically.
